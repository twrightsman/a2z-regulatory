---
jupytext:
  formats: ipynb,md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.13.1
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# Figure 2

```{code-cell} ipython3
from collections import Counter
import glob
import hashlib
import json
import math
from pathlib import Path
from string import capwords

import pandas as pd
from pyfaidx import Fasta
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import sklearn
from sklearn.metrics import average_precision_score, roc_auc_score
import tensorflow as tf
import tensorflow.keras as k

from a2z.data import seq_one_hot_encode, IntervalReferenceDataset
from a2z.models import allow_growth
from a2z.plots import pr_curve, tpr_curve

allow_growth()
```

```{code-cell} ipython3
config_name = "accessibility_base"
with open(f"../01_models/configs/{config_name}.json") as config_file:
    config = json.load(config_file)
```

```{code-cell} ipython3
scATAC = pd.read_csv(
    "../../data/marand_2021_scATAC/GSE155178_maize_scATAC_atlas_ACR_celltype_CPM.txt",
    header = 0,
    sep = "\t"
).reset_index().rename(columns = {'index': 'locus'})

seq_index = scATAC['locus'].str.split('_', expand = True).astype({1: int, 2: int}).rename(columns = {0: 'seqid', 1: 'start', 2: 'end'})

window_size = config['preprocessing']['window_size']
peak_midpoints = ((seq_index['start'] + seq_index['end']) / 2).astype(int)
seq_index['start'] = peak_midpoints - (window_size // 2)
seq_index['end'] = peak_midpoints + (window_size // 2)

scATAC = pd.concat([seq_index, scATAC.drop(columns = 'locus')], axis = 'columns')

scATAC = scATAC.sort_values(by = ['seqid', 'start']).set_index(keys = ['seqid', 'start', 'end'])
```

```{code-cell} ipython3
# load in pan-Angiosperm model trained on everything but maize
# can take a random model (here it's just the first) since the auPR doesn't change much between different samples of the same model
no_maize_model_path = (f"../01_models/tmp/results/{config_name}/Zea_mays/0/model")
no_maize_model = k.models.load_model(no_maize_model_path)
```

```{code-cell} ipython3
test_data = pd.read_csv(
    "tmp/scATAC.unlabeled.bed",
    sep = "\t",
    names = ['seqid', 'start', 'end', 'target'],
    dtype = {
        'seqid': 'category',
        'start': int,
        'end': int,
        'target': np.byte
    },
    usecols = ['seqid', 'start', 'end']
)
test_data['species'] = 'Zea mays'
```

```{code-cell} ipython3
%%time

scATAC_cache = Path("tmp/preds.tsv")
if scATAC_cache.exists():
    preds = pd.read_table(
        scATAC_cache,
        names = ['prediction'],
        dtype = {'prediction': float}
    )
    test_data['prediction'] = preds['prediction'].to_numpy()
else:
    # ~20 mins
    test_dataset = IntervalReferenceDataset(test_data, references = {'Zea mays': Fasta("../../data/marand_2021_scATAC/AGPv4.fa", as_raw = True)} , no_target = True)
    test_data['prediction'] = no_maize_model.predict(
        test_dataset
    ).flatten()
    test_data['prediction'].to_csv(
        scATAC_cache,
        sep = "\t",
        header = False,
        index = False
    )
test_data = test_data.sort_values(['seqid', 'start']).set_index(['seqid', 'start', 'end'])
```

```{code-cell} ipython3
# matrix counts were generated by normalizing to CPM then adding 5 (to avoid logging zero) then log2 transformed
# so can define closed regions in that cell-type as less than log2(5)
scATAC_binarized_all = (scATAC > math.log2(5)).astype(int).reindex(test_data.index, fill_value = 0)
```

```{code-cell} ipython3
%%time

peak_specificity = scATAC_binarized_all.apply(sum, axis = 1)
always_closed = (peak_specificity == 0)
test_data['target'] = (peak_specificity > 0).astype(int)
```

```{code-cell} ipython3
assert test_data.loc[always_closed]['target'].sum() == 0
```

```{code-cell} ipython3
_ = plt.hist(test_data.loc[test_data['target'] == 1, 'prediction'])
```

```{code-cell} ipython3
_ = plt.hist(test_data.loc[test_data['target'] == 0, 'prediction'])
```

```{code-cell} ipython3
%%time

# ~2m30s
auPRs = []
recalls = []
thresholds = []
for sp in range(1, peak_specificity.max() + 1):
    peaks = test_data.loc[(peak_specificity == sp) | always_closed]
    #peaks = test_data.loc[peak_specificity == sp]
    y = peaks['target']
    y_hat = peaks['prediction']
    precision, recall, threshold = sklearn.metrics.precision_recall_curve(y, y_hat)
    auPRs.append(sklearn.metrics.average_precision_score(y, y_hat))
    recalls.append(recall)
    thresholds.append(threshold)
```

```{code-cell} ipython3
fig2c_precision = {}
fig2c_recall = {}
fig2c_thresholds = {}

for cell_type in ['guard_cell.9.87', 'trichoblast.3.35']:
    y = scATAC_binarized_all[cell_type]
    y_hat = test_data['prediction']
    label = capwords(cell_type.split('.')[0].replace('_', ' '))
    fig2c_precision[label], fig2c_recall[label], fig2c_thresholds[label] = sklearn.metrics.precision_recall_curve(y, y_hat)

y = (peak_specificity > 0).astype(int)
y_hat = test_data['prediction']
fig2c_precision['Union'], fig2c_recall['Union'], fig2c_thresholds['Union'] = sklearn.metrics.precision_recall_curve(y, y_hat)
```

```{code-cell} ipython3
fig, ax = plt.subplots(figsize = (6, 5))

ax.hist(peak_specificity.loc[peak_specificity > 0], bins = np.arange(0, 94, 2))
ax.set_xlim(0, 92)
ax.set_xlabel("Number of cell types peak is open in")
ax.set_ylabel("Peak Count")

fig.savefig('figs/peak_celltype_specificity.png', dpi = 300, facecolor = "white")
```

```{code-cell} ipython3
fig2 = plt.figure(constrained_layout = True, figsize = (11, 5))

gs = matplotlib.gridspec.GridSpec(1, 2, figure = fig2)
ax2a = fig2.add_subplot(gs[0, 0])
ax2b = fig2.add_subplot(gs[0, 1])

# Fig 2A
max_sp = peak_specificity.max()
aucs = [sklearn.metrics.auc(thresholds[sp], recalls[sp][:-1]) for sp in range(max_sp)]
ax2a.scatter(np.arange(max_sp), aucs, s = 20)
ax2a.set_xlabel('Number of cell-types peak is open in')
ax2a.set_ylabel('Area under the threshold-recall curve')

# Fig 2B
for label in fig2c_recall:
    ax2b.plot(fig2c_recall[label], fig2c_precision[label], label = label)
ax2b.set_xlim(0, 1)
ax2b.set_xlabel('Recall')
ax2b.set_ylim(0, 1)
ax2b.set_ylabel('Precision')
ax2b.legend()

fig2.savefig('figs/fig2.png', dpi = 300, facecolor = "white")
```

```{code-cell} ipython3
precision_baseline = [v / len(test_data) for k, v in sorted(Counter(peak_specificity).items(), key = lambda t: t[0])][1:]
```

```{code-cell} ipython3
fig, ax = plt.subplots()

ax.scatter(np.arange(1, len(auPRs) + 1), auPRs, alpha = 0.4)
ax.plot(np.arange(1, len(precision_baseline) + 1), precision_baseline, label = "Baseline", linestyle = "--", color = 'gray')
ax.set_xlabel('Number of cell-types peak is open in')
ax.set_ylabel('auPR')
ax.legend()
```

```{code-cell} ipython3

```
